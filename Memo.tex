
\documentclass[a4paper,12pt]{article}


%\usepackage[spanish,activeacute]{babel} 
\usepackage[utf8]{inputenc} 
\usepackage{latexsym,amsfonts,amsmath,mathrsfs,amssymb}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{makeidx}        
\usepackage{multicol}        



\author{Pedro Parrado Rodríguez\\* {\small PhD}}


\title{{\bf{Memory}}} 

% La fecha de entrega del informe y el número de la versión (1ª, 2ª, 3ª,..)
\date{{\scriptsize }}
\oddsidemargin0cm
\textwidth16cm


% Comenzamos el documento 
%jbg%\usepackage{Sweave}
\begin{document}

% Pone el título que hemos introducido arriba
\maketitle

\tableofcontents
\newpage


%\chapter{First Year}
\section{Warm up}
\subsection{Lookup tables}
A lookup table is the simplest decoder. It is a table in which we have the correction to apply for every syndrome. 

To generate the lookup table for the simplest codes, I have explored all possible combinations of up to 5 errors. Then for each error combination, I find the syndrome that it generates, and I add it to the lookuptable if there is no other error configuration for that syndrome with less errors (meaning, we only keep the error configurations with the minimum weight).

Lookup tables are probably the fastest decoders, as they take just one step to decode a syndrome. The problem comes at generating them, as the size of the table grows exponentially with the number of stabilizers ($2^N$), and both filling that table and storing it becomes impossible after increasing the system size just a bit. 


\subsection{MonteCarlo simulations with Lookup tables}

To check the efficiency of the lookuptables, I have run some MonteCarlo simulations. The simulation works with the following steps:
\begin{enumerate}
\item First, we generate an error configuration by throwing errors at each qubit with probability $p$. For each error appearing in the code, we apply a pauli operator $X$, $Y$ or $Z$ with probability $1/3$.
\item Second, we measure the syndrome for the system with that error configuration.
\item Then, we apply the correction from the lookuptable for that syndrome.
\item Finally, we check the combination of the error and our correction, to see if there is a logical error or not in the final result.
\end{enumerate}

From each of those simulations we get either a 1 in case of logical error, or a 0 in case of a proper correction. We then repeat this simulation several times (of the order of $10^4$ at least) to find the probability of logical error, and we compute that probability for different values of $p$ (the probability of an error in a single qubit) to find the behavior of the probability of logical error, and to find the threshold (when $p_{Logical\backspace error}=p_{error\backspace in \backspace a \backspace qubit}$).


\section{Surface Code}
\subsection{MLE Decoder}
\subsection{MonteCarlo simulation}
\subsection{Measurement errors Decoder}
\subsection{MonteCarlo simulation}

\section{Color Code}
\subsection{Rescaling decoder}
\subsubsection{Outline of the decoder}

\begin{enumerate}
\item Read the Syndrome from the errors in the qubits.
\item Assign an initial splitting (or initial split probabilities).
\item Update the splittings (or the split probabilities) until convergence.
\item Decode the cells independently according to the splitting from the previous step.
\item Create the new rescaled code, and assign to each logical qubit the probability of a logical error in the cell.
\item Apply the decoder again, until the size of the code is small enough to apply a complete lookuptable.
\item Apply the corrections of the higher levels to the lower ones.


\end{enumerate}

\subsubsection{Hard splitting method}
This algorithm for splitting is based on changing each individual splitting to a better one asuming the others are constant, until convergence. Therefore, the core of the algorithm is to compute the probability of a given splitting:

\begin{equation}
p(s_0^u|s_1s_2s_1's_2')=\frac{p(s_0^u|s_1s_2)p(s_0^l|s_1's_2')}{p(s_0^u|s_1s_2)p(s_0^l|s_1's_2')+[1-p(s_0^u|s_1s_2)][1-p(s_0^l|s_1's_2']}
\end{equation}


\begin{equation}
p(s_0^u|s_1s_2)=\frac{p(s_0^us_1s_2)}{p(s_0^u=1,s_1s_2)+p(s_0^u=0,s_1s_2)}
\end{equation}




% IMAGEN

%\begin{figure}[ht!]
%\begin{center}
%\includegraphics[height=90mm]{IMAGEN.png}
%\end{center}
%\end{figure}
%



%  TABLA

%\begin{table}[h]
%\begin{center}
%\begin{tabular}{|c|c|c|c|c|c|c|}
%\hline
%$		$&$		$&$		$&$		$&$		$&$		$&$		$\\
%\hline
%\end{tabular}
%\end{center}
%\end{table}





\end{document}
